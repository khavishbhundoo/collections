<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# stack

```go
import "collections/concurrent/stack"
```

## Index

- [type Stack](<#Stack>)
    - [func New\[T any\]\(\) \*Stack\[T\]](<#New>)
    - [func NewWithCapacity\[T any\]\(capacity int\) \*Stack\[T\]](<#NewWithCapacity>)
    - [func \(s \*Stack\[T\]\) Clear\(\)](<#Stack[T].Clear>)
    - [func \(s \*Stack\[T\]\) Len\(\) int](<#Stack[T].Len>)
    - [func \(s \*Stack\[T\]\) Peek\(\) \(T, bool\)](<#Stack[T].Peek>)
    - [func \(s \*Stack\[T\]\) Pop\(\) \(T, bool\)](<#Stack[T].Pop>)
    - [func \(s \*Stack\[T\]\) Push\(item T\)](<#Stack[T].Push>)
    - [func \(s \*Stack\[T\]\) PushMany\(item ...T\)](<#Stack[T].PushMany>)
    - [func \(s \*Stack\[T\]\) Reset\(\)](<#Stack[T].Reset>)


<a name="Stack"></a>
## type [Stack](<https://github.com/khavishbhundoo/collections/blob/main/concurrent/stack/stack.go#L13-L18>)

Stack is a generic, thread\-safe LIFO \(last\-in\-first\-out\) stack implementation backed by a dynamically resizing slice.The zero value of Stack\[T\] is ready to use without initialization.

Use New\(\) or NewWithCapacity\(\) if you prefer an explicit constructor or want to set an initial capacity. All operations on Stack are safe for concurrent use by multiple goroutines. If you do not need thread\-safety, use the collections/stack package instead for better performance.

```go
type Stack[T any] struct {
    // contains filtered or unexported fields
}
```

<details><summary>Example</summary>
<p>



```go
package main

import (
        "collections/concurrent/stack"
        "fmt"
        "sync"
)

func main() {
        s := stack.New[int]()
        s.PushMany(1, 2)
        s.Push(3)

        s2 := stack.NewWithCapacity[int](4)
        s2.PushMany(1, 2, 3, 4)
        s2.Push(3)
        val, ok := s2.Pop()
        fmt.Println(val, ok)

        val, ok = s.Pop()
        fmt.Println(val, ok)
        fmt.Println(s.Len())
        peek, ok := s.Peek()
        fmt.Println(peek, ok)
        fmt.Println(s.Len())
        s.Pop()
        s.Pop()
        val, ok = s.Pop()
        fmt.Println(val, ok)
        peek, ok = s.Peek()
        fmt.Println(peek, ok)

        //The zero value of Stack[T] is ready to use without initialization
        var s3 stack.Stack[int]
        s3.Push(1)
        val, ok = s3.Pop()
        fmt.Println(val, ok)

        var wg sync.WaitGroup
        cs := stack.New[int]()
        for i := 1; i <= 3; i++ {
                wg.Add(1)
                go func(v int) {
                        defer wg.Done()
                        cs.Push(v)
                }(i)
        }
        wg.Wait()
        fmt.Println(cs.Len())

}
```

#### Output

```
3 true
3 true
2
2 true
2
0 false
0 false
1 true
3
```

</p>
</details>

<a name="New"></a>
### func [New](<https://github.com/khavishbhundoo/collections/blob/main/concurrent/stack/stack.go#L30>)

```go
func New[T any]() *Stack[T]
```

New creates an empty stack of type T with no pre\-allocated capacity. Use this when you don't know in advance how many elements you will push. This is equivalent to creating a stack as \`var s stack.Stack\[int\]\`

<a name="NewWithCapacity"></a>
### func [NewWithCapacity](<https://github.com/khavishbhundoo/collections/blob/main/concurrent/stack/stack.go#L40>)

```go
func NewWithCapacity[T any](capacity int) *Stack[T]
```

NewWithCapacity creates an empty stack of type T with a pre\-allocated capacity. This avoids repeated allocations if you know roughly how many elements youâ€™ll push.

<a name="Stack[T].Clear"></a>
### func \(\*Stack\[T\]\) [Clear](<https://github.com/khavishbhundoo/collections/blob/main/concurrent/stack/stack.go#L140>)

```go
func (s *Stack[T]) Clear()
```

Clear removes all items and reallocates a slice with the initial capacity \(if any\). Use this to shrink the backing array explicitly.

<a name="Stack[T].Len"></a>
### func \(\*Stack\[T\]\) [Len](<https://github.com/khavishbhundoo/collections/blob/main/concurrent/stack/stack.go#L122>)

```go
func (s *Stack[T]) Len() int
```

Len returns the current number of items in the stack.

<a name="Stack[T].Peek"></a>
### func \(\*Stack\[T\]\) [Peek](<https://github.com/khavishbhundoo/collections/blob/main/concurrent/stack/stack.go#L111>)

```go
func (s *Stack[T]) Peek() (T, bool)
```

Peek returns the top element of the stack without removing it. The boolean return is false if the stack is empty.

<a name="Stack[T].Pop"></a>
### func \(\*Stack\[T\]\) [Pop](<https://github.com/khavishbhundoo/collections/blob/main/concurrent/stack/stack.go#L67>)

```go
func (s *Stack[T]) Pop() (T, bool)
```

Pop removes and returns the top element of the stack. The boolean return is false if the stack is empty. The stack may shrink its capacity automatically if it has grown significantly and is mostly empty.

<a name="Stack[T].Push"></a>
### func \(\*Stack\[T\]\) [Push](<https://github.com/khavishbhundoo/collections/blob/main/concurrent/stack/stack.go#L57>)

```go
func (s *Stack[T]) Push(item T)
```

Push adds a single item to the top of the stack.

<a name="Stack[T].PushMany"></a>
### func \(\*Stack\[T\]\) [PushMany](<https://github.com/khavishbhundoo/collections/blob/main/concurrent/stack/stack.go#L50>)

```go
func (s *Stack[T]) PushMany(item ...T)
```

PushMany pushes one or more items onto the stack in order. Equivalent to calling Push repeatedly but more efficient when adding multiple elements.

<a name="Stack[T].Reset"></a>
### func \(\*Stack\[T\]\) [Reset](<https://github.com/khavishbhundoo/collections/blob/main/concurrent/stack/stack.go#L131>)

```go
func (s *Stack[T]) Reset()
```

Reset clears all items but keeps the current capacity of the underlying slice. This is faster than Clear\(\) when you expect to reuse the same stack size.

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)